<html>

<head>
<title>JAVA Notes</title>
</head>

<body text=black bgcolor=white>

<h2 align=center>JAVA Notes 20</h2>

<h3>Tuesday, April 17th, 2001 </h3>


<!-- **************************** NEW TOPIC **************************************** -->
<hr width=100%>
<pre>
<b>Intro to Threading: </b>

Doing multiple processes at the same time using the same machine. One processor can
only execute one process at one time. Therefore, even when you have more than one 
process running on your computer, at one time only one process is being executed.
What actually happens is that the processor is switching between the different 
processes at very high speeds, such that we don't notice the time delay. A 400 MHz
processor executes at 400 * 10<sup>6</sup> cycles/second.

C++ And Java are ruling currently because they can achieve multi-processing. But
Java does not perform multiprocessing, it does multi-threading. A process is an object
that consists of multiple sub-processes, which are called threads in Java. 
Multi-processing in C++ is an advanced topic as it is not easy to achieve, whereas 
creating threads in Java is easy.

Threads are objects generated by the OS, that is assigned a particular task. Each 
thread has its own flow of execution. The OS makes sure that the threads work together.

</pre>


<!-- **************************** NEW TOPIC **************************************** -->
<hr width=100%>
<pre>
<b>Creating Threads: </b>

Thread class: It has multiple constructors.

Every thread has a numeric priority assigned to it. 
Min priority - less than 5
Max priority - more than 5
Norm priority - equal to 5 (default)

OS threads are called daemon threads, eg. the garbage collector (GC). Main thread is
the first thread to be generated, and then it in turn generates all other threads. 
In technical terms the main thread is actually a thread group.

Example1:
<i>// Controlling the main Thread.
class CurrentThreadDemo {
  public static void main(String args[]) {
    // making t the reference for the current running thread
    Thread t = Thread.currentThread();

    // printing the thread reference t, println uses to_string method
    System.out.println("Current thread: " + t);

    // change the name of the thread
    t.setName("My Thread");
    System.out.println("After name change: " + t);

    try {
      for(int n = 5; n > 0; n--) {
        System.out.println(n);
        Thread.sleep(1000); // suspend for 1000 milliseconds
 	// NOTE: Always put sleep in try/catch block
      }
    }
    // in case if the OS or another thread trys to wake it up 
    catch (InterruptedException e) { 
      System.out.println("Main thread interrupted");
    }
  }
}</i>

Output:
Current thread: Thread[main,5,main]
After name change: Thread[My Thread,5,main]
5  <font color=red>(there is a one second delay on every one of these lines)</font>
4
3
2
1

<b>Thread[main,5,main]</b>
First main: Thread name
5: priority
Second main: Thread type

</pre>


<!-- **************************** NEW TOPIC **************************************** -->
<hr width=100%>
<pre>
<b>Extends Thread: </b>

When thread is created it is in its Start or Ready state. When the OS runs it, it is 
in its wait or block state. And then it goes back to its start/ready state. 

       wait
       /   \
      /     \  
down /       \ Up
    /         \
   /           \
Start    ----> Run ----> Dead
or Ready

Example1:
<i>// Create a second thread by extending Thread
class NewThread extends Thread {

  NewThread() {
    // Create a new, second thread
    super("Demo Thread");
    System.out.println("Child thread: " + this);
    start(); // Start the thread, registers it with the OS and asks it to run it
    // OS runs it according to its priority
  }

  // This is the entry point for the second thread.
  public void run() {
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println("Child Thread: " + i);
        Thread.sleep(500);
      }
    } catch (InterruptedException e) {
      System.out.println("Child interrupted.");
    }
    System.out.println("Exiting child thread.");
  }
}

class ExtendThread {
  public static void main(String args[]) {
    new NewThread(); // create a new thread

    try {
      for(int i = 5; i > 0; i--) {
        System.out.println("Main Thread: " + i);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {
      System.out.println("Main thread interrupted.");
    }
    System.out.println("Main thread exiting.");
  }
}</i>

Output:
Child thread: Thread[Demo Thread,5,main]
Main Thread: 5
Child Thread: 5
Child Thread: 4
Main Thread: 4
Child Thread: 3
Child Thread: 2
Child Thread: 1
Main Thread: 3
Exiting child thread.
Main Thread: 2
Main Thread: 1
Main thread exiting.

</pre>


<!-- **************************** NEW TOPIC **************************************** -->
<hr width=100%>
<pre>
<b>Implements Runnable Interface: </b>

implements Runnable is a better approach than extends, because it allows you all of
the Thread methods and you are still not confined to it. You can have better multiple
inheritence this way.

Example:
<i>// Create a second thread.
class NewThread implements Runnable {
  Thread t; // need object to call interface methods

  NewThread() {
    // Create a new, second thread
    t = new Thread(this, "Demo Thread");
    System.out.println("Child thread: " + t);
    t.start(); // Start the thread using object reference t
  }

  // This is the entry point for the second thread.
  public void run() {
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println("Child Thread: " + i);
        Thread.sleep(500);
      }
    } catch (InterruptedException e) {
      System.out.println("Child interrupted.");
    }
    System.out.println("Exiting child thread.");
  }
}

class ThreadDemo {
  public static void main(String args[]) {
    new NewThread(); // create a new thread

    try {
      for(int i = 5; i > 0; i--) {
        System.out.println("Main Thread: " + i);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {
      System.out.println("Main thread interrupted.");
    }
    System.out.println("Main thread exiting.");
  }
}</i>

Output:
Child thread: Thread[Demo Thread,5,main]
Main Thread: 5
Child Thread: 5
Child Thread: 4
Main Thread: 4
Child Thread: 3
Child Thread: 2
Main Thread: 3
Child Thread: 1
Exiting child thread.
Main Thread: 2
Main Thread: 1
Main thread exiting.

</pre>


<!-- **************************** NEW TOPIC **************************************** -->
<hr width=100%>
<pre>
<b>Creating multiple threads: </b>

Example:
<i>// Create multiple threads.
class NewThread implements Runnable {
  String name; // name of thread
  Thread t;

  NewThread(String threadname) {
    name = threadname;
    t = new Thread(this, name);
    System.out.println("New thread: " + t);
    t.start(); // Start the thread
  }

  // This is the entry point for thread.
  public void run() {
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println(name + ": " + i);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {
      System.out.println(name + "Interrupted");
    }
    System.out.println(name + " exiting.");
  }
}

class MultiThreadDemo {
  public static void main(String args[]) {
    new NewThread("One"); // start threads
    new NewThread("Two");
    new NewThread("Three");

    try {
      // wait for other threads to end
      Thread.sleep(10000);
    } catch (InterruptedException e) {
      System.out.println("Main thread Interrupted");
    }

    System.out.println("Main thread exiting.");
  }
}</i>

Output:
New thread: Thread[One,5,main]
New thread: Thread[Two,5,main]
New thread: Thread[Three,5,main]
One: 5
Two: 5
Three: 5
Three: 4
Two: 4
One: 4
One: 3
Two: 3
Three: 3
Three: 2
Two: 2
One: 2
One: 1
Two: 1
Three: 1
One exiting.
Two exiting.
Three exiting. <font color=red>Waits a bit before going to next line</font>
Main thread exiting.

</pre>


<!-- **************************** NEW TOPIC **************************************** -->
<hr width=100%>
<pre>
<b>Thread Status: </b>

In older versions of JDK, if the main thread ends before the child threads, it would
give an error. Although the new JDK does not give an error any more, and the program
works fine, it is good practice to end the main thread after all other threads are 
dead.

isAlive();
Used to check whether a Thread has terminated or not.
NOTE: In wait state, thread is still alive

join();
After the child threads are done, they join the main thread again. This is used to
check whether the child threads have joined up with the main thread already or not.

<img src=images/20_1.gif>

Example:
<i>class NewThread implements Runnable {
  String name; // name of thread
  Thread t;

  NewThread(String threadname) {
    name = threadname;
    t = new Thread(this, name);
    System.out.println("New thread: " + t);
    t.start(); // Start the thread
  }

  // This is the entry point for thread.
  public void run() {
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println(name + ": " + i);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {
      System.out.println(name + " interrupted.");
    }
    System.out.println(name + " exiting.");
  }
}

class DemoJoin {
  public static void main(String args[]) {
    NewThread ob1 = new NewThread("One");
    NewThread ob2 = new NewThread("Two");
    NewThread ob3 = new NewThread("Three");

    System.out.println("Thread One is alive: "
                        + ob1.t.isAlive());
    System.out.println("Thread Two is alive: "
                        + ob2.t.isAlive());
    System.out.println("Thread Three is alive: "
                        + ob3.t.isAlive());
    // wait for threads to finish
    try {
      System.out.println("Waiting for threads to finish.");
      ob1.t.join();
      ob2.t.join();
      ob3.t.join();
    } catch (InterruptedException e) {
      System.out.println("Main thread Interrupted");
    }

    System.out.println("Thread One is alive: "
                        + ob1.t.isAlive());
    System.out.println("Thread Two is alive: "
                        + ob2.t.isAlive());
    System.out.println("Thread Three is alive: "
                        + ob3.t.isAlive());

    System.out.println("Main thread exiting.");
  }
}</i>

Output:
New thread: Thread[One,5,main]
New thread: Thread[Two,5,main]
New thread: Thread[Three,5,main]
Two: 5
One: 5
Thread One is alive: true
Three: 5
Thread Two is alive: true
Thread Three is alive: true
Waiting for threads to finish.
One: 4
Three: 4
Two: 4
Two: 3
Three: 3
One: 3
One: 2
Three: 2
Two: 2
One: 1
Two: 1
Three: 1
Two exiting.
Three exiting.
One exiting.
Thread One is alive: false
Thread Two is alive: false
Thread Three is alive: false <font color=red>Program moves to next line immediately</font>
Main thread exiting.

</pre>

</body>
</html>